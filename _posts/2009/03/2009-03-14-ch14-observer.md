---
layout: post
title: "[閱讀筆記][Design Pattern] Ch14.觀察者模式(Observer)"
date: 2009-03-14 06:01:00 +0800
categories: [Notes,Design Pattern]
tags: [大話設計模式,Design Pattern]
---

# 觀察者模式(Observer)

觀察者模式(`Observer`)又叫做「發佈-訂閱(`Publish`/`Subscribe`)模式」。      

觀察者模式(`Observer`)定義了一種一對多的依賴關係，讓多個觀察者物件同時監聽某一個主題物件。這個主題物件在狀態發生變化時，會通知所有觀察者物件，使它們能夠自動更新自己。

## 觀察者模式(Observer)結構

- `Subject`類別，可翻譯為主題或抽象通知者，一般用一個抽象類別或者一個介面實現。它把所有對觀察者物件的參考保存在一個聚集裡，每個主題都可以有任何數量的觀察者。抽象主題提供一個介面，可以增加和除觀察者物件。 

- `Observer`類別，抽象觀察者，為所有的具體觀察者定義一個介面，在得到主題的通知時更新自己。  

- `ConcreteSubject` 類別，具體主題，將有關狀態存入具體觀察者物件；在具體主題的內部狀態改變時，發出通知給所有登記過的觀察者。    
- `ConcreteObserver` 類別，具體觀察者，實現抽象觀察者角色所要求的更新介面，以便使本身的狀態與主題相協調。

```
Subject 主題或抽象通知者，它把所有對觀察者物件的參考保存在一個聚集裡，每個主題都可以有任何數量的觀察者。抽象主題提供一個介面，可以增加和除觀察者物件。 
- observer
+ Attach(in : Obsever)
+ Detach(in : Obsever)
+ Notify()

    ConcreteSubject 具體主題，具體主題，將有關狀態存入具體觀察者物件；在具體主題的內部狀態改變時，發出通知給所有登記過的觀察者。
    + SubjectState

Observer 抽象觀察者，為所有的具體觀察者定義一個介面，在得到主題的通知時更新自己。
+ Update()

    ConcreteObserver 具體觀察者，具體觀察者，實現抽象觀察者角色所要求的更新介面，以便使本身的狀態與主題相協調。
    - subject
    - observerState
    + Update()
```

## 觀察者模式(Observer)程式碼
### Subject類別(主題或抽象通知者)

`Subject`類別，可翻譯為主題或抽象通知者，一般用一個抽象類別或者一個介面實現。它把所有對觀察者物件的參考保存在一個聚集裡，每個主題都可以有任何數量的觀察者。抽象主題提供一個介面，可以增加和除觀察者物件。 

```c#
//Subject類別，可翻譯為主題或抽象通知者，一般用一個抽象類別或者一個介面實現。
//它把所有對觀察者物件的參考保存在一個聚集裡，每個主題都可以有任何數量的觀察者。
//抽象主題提供一個介面，可以增加和除觀察者物件。 
abstract class Subject {
    IList<Observer> observers = new List<Observer>();

    //增加觀察者
    public void Attach(Observer observer) {
        observers.Add();
    }

    //移除觀察者
    public void Detach(Observer observer) {
        observers.Remove();
    }
    //通知
    public void Notify() {
        foreach(Observer o in observers) {
            o.Update();
        }
    }
}
```

### Observer類別(抽象觀察者)
`Observer`類別，抽象觀察者，為所有的具體觀察者定義一個介面，在得到主題的通知時更新自己。        

這個介面叫做更新介面。抽象觀察者一般用一個抽象類別或者一個介面實現。更新介面通常包含一個`Update()`方法，這個方法叫做更新方法。

```c#
//Observer類別，抽象觀察者，為所有的具體觀察者定義一個介面，在得到主題的通知時更新自己。 
//這個介面叫做更新介面。抽象觀察者一般用一個抽象類別或者一個介面實現。
//更新介面通常包含一個Update()方法，這個方法叫做更新方法。
interface Observer {
    void Update();
}
```
> 具體的觀察者完全有可能是風馬牛不相及的類別，可以用介面`interface`比較好。

### ConcreteSubject類別(具體主題)
`ConcreteSubject`類別，具體主題，將有關狀態存入具體觀察者物件；在具體主題的內部狀態改變時，發出通知給所有登記過的觀察者。   

具體主題角色通常用一個具體子類別實現。

```c#
class ConcreteSubject: Subject {
    //具體被觀察者狀態
    public string SubjectState {get; set;}
}
```

### ConcreteObserver類別(具體觀察者)
`ConcreteObserver`類別，具體觀察者，實現抽象觀察者角色所要求的更新介面，以便使本身的狀態與主題相協調。      

具體觀察者角色可以保存一個指向具體主題物件的參考。      

具體觀察者角色通常用一個具體子類別實現。

```c#
class ConcreteObserver: Observer {
    ConcreteSubject subject; //具體主題/通知者
    string observerState;
    string name;

    public ConcreteSubject Subject {get; set;}

    public ConcreteObserver(ConcreteSubject subject, string name) {
        this.subject = subject;
        this.name = name;
    }

    public override void Update() {
        observerState = subject.SubjectState;
        Console.WriteLine($"觀察者{name}的新狀態是{observerState}");
    }
}
```

### 用戶端程式碼

```c#
ConcreteSubject s = new ConcreteSubject();
s.Attach(new ConcreteObserver(s, "X"));
s.Attach(new ConcreteObserver(s, "Y"));
s.Attach(new ConcreteObserver(s, "Z"));
s.SubjectState = "ABC";
s.Notify();

/* 顯示的結果:
觀察者X的新狀態是ABC
觀察者Y的新狀態是ABC
觀察者Z的新狀態是ABC
*/
```

## 什麼時候考慮用「觀察者模式(Observer)」呢？      

當一個物件的改變需要同時改變其他物件時。而且它不知道到底有多少物件有待改變時，應該考慮使用「觀察者模式(Observer)」。


如果通知者和觀察者之間根本互相不知道，由用戶端來決定通知誰，那就好了。
# 事件委託實現

老闆回來了，我不知道…


```c#
//通知者介面
interface Subject {
    string SubjectState { get; set; }
    void Notify();
}

//看股票的同事
class StockObserver {
    public StockObserver() {

    }
}
//看NBA的同事
class NBAObsesrver {


}
```
