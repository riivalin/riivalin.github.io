---
layout: post
title: "[C# 筆記] review5：泛型集合、文件流、多態、裝拆箱"
date: 2011-01-21 22:29:00 +0800
categories: [Notes, C#]
tags: [C#]
---

## 泛型集合
### List<T>
`List<int> list = new List<int>();`

### Dictionary<Tkey, Tvalue>
`Dictionary<int, string> dic = new Dictionary<int, string>()`
  
> 兩者都不會發生裝箱和拆箱的問題，因為他們裡面裝的元素都是同類型的

### 他們添加數據的方法
1. Add方法   
`dic.add(1,"張三")`加入相同的key會拋異常  
2. 根據key  
`dic[1]="張三";`加人相同的key不會拋異常，只會覆蓋原來的值    

### 遍歷元素的方式
```c#
foreach (KeyValuePair<int,string> kv in dic)
{
    Console.WriteLine($"key: {kv.Key}, value: {kv.Value}");
}
```


## 文件流 FileStream、StreamReader、StreamWrite
### FileStream 
操作字節/位元組Byte，意味著可以操作所有類型的文件
可以用來處理大文件   

寫在`using{}`裡面，可以幫我們
1. 關閉stream
2. 釋放stream所占的資源

### 範例：FileStream 讀取文件
```c#
//FileMode.OpenOrCreate: 如果沒有檔案就建立，避免拋異常
using (FileStream fsRead = new FileStream(@"C:\Users\rivalin\Desktop\new.txt", FileMode.OpenOrCreate, FileAccess.Read))
{
    //它讀的時候是放在一個byte[]裡面
    byte[] buffer = new byte[1024 * 1024 * 5];

    //本次實際讀到的byte[]數
    //如果這邊是大數據的話，就要用循環來做
    int r = fsRead.Read(buffer, 0, buffer.Length); //把讀到的放進buffer，從頭開始讀，所以是0，讀的長度為buffer.Length

    //將位元組byte[]中的每一個元素，按照我們指定的編碼格式解析成字串
    string s= Encoding.Default.GetString(buffer, 0, r); //從頭開始解，所以是0，解碼r個

    Console.WriteLine(s);
}
```
### 範例：FileStream 寫入文件

使用`FileMode.OpenOrCreate`寫入會覆蓋內容，不想被覆蓋，可以用`FileMode.Append`它會追加在內容最後
```c#
using (FileStream fsWrite = new FileStream(@"C:\Users\rivalin\Desktop\new.txt", FileMode.Append, FileAccess.Write))
{
    string s = "今天要學習好多好多東西哦…";

    //fsWrite在寫入的時候，是寫入byte[]，所以要先把字串轉成byte[]
    byte[] buffer = Encoding.Default.GetBytes(s);
    fsWrite.Write(buffer, 0, buffer.Length);
    Console.WriteLine("done");
}
```
FileStream 是必須要掌握的

### StreamReader, StreamWrite
操作字符/字元，只能操作文本文件

### File
用來處理小文件

## 拆裝箱
### 裝箱：
將值類型轉換為引用類型  
(是給值類型的引用類型)   

### 拆箱：
將引用類型轉換為值類型   
(是給引用類型的值類型)   

我們應該避免在程式碼中發生裝箱或者拆箱。    

它們影響的是時間，程式碼要避免拆裝箱，    
怎麼判別，看他們有沒有繼承關係    

## 多態
- 虛方法 virtual (virtual, override)
父類方法有實現
- 抽象方法 abstract (abstract, overrid)
父類方法不能實現
- 介面  

### 多態是什麼？    
多態就是為了讓一個對象能夠表現出多種狀態、多種類型
    
### 寫多態的好處是什麼？
- 減少程式碼
- 尋找個各各子類間的差異，寫出通用的程式碼
   

## 練習：虛方法和抽象類
老師可以起立，學生也可以起立，校長也可以起立   
用多態來實現"起立"

```c#
//聲明父類去指向子類對象
Person p = new HeadMaster();//new Teacher();//new Student();
//調的依然是父類的StandUp()方法，
//但是這個方法己經被子類重新寫過，
//所以最終執行的是子類的方法
//但是最終執行的是哪一個子類的方法，
//取決於你裝的是誰的子類
p.StandUp(); 

Console.ReadKey();

//父類
//因為有抽象方法，所以類別只能是抽象類別，因為它不完整，所以不能產生物件使用
public abstract class Person {
    //因為每個人起立的方式不同，所以使用抽象去定義方法，讓子類重寫它
    public abstract void StandUp();
}
//子類
public class Student : Person {
    public override void StandUp() {
        Console.WriteLine("學生起立，說老師好");
    }
}
public class Teacher : Person {
    public override void StandUp() {
        Console.WriteLine("老師起立，說校長好");
    }
}
public class HeadMaster : Person {
    public override void StandUp() {
        Console.WriteLine("校長起立，說領導好");
    }
}
```
### 什麼時候用虛方法？
方法裡面有實現的時候
  
---

後面用比較多是抽象類